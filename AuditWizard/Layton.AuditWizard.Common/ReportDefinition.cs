using System;
using System.Collections.Generic;
using System.Data;
using System.Drawing;
using System.IO;
using System.Text;
using System.ComponentModel;
using System.Windows.Forms;
using System.Xml;
//
using Infragistics.Win.UltraWinGrid;
using Infragistics.Win.UltraWinGrid.DocumentExport;
using Infragistics.Win.UltraWinGrid.ExcelExport;
//
using Layton.Common.Controls;
using Layton.AuditWizard.Common;
using Layton.AuditWizard.DataAccess;

namespace Layton.AuditWizard.Common
{
	public class ReportDefinition
	{
		#region Data
		
		public static string REPORTEXTENSION = ".awr";
		public enum eReportType	{ licensing, auditeddata, history ,internet ,filesystem };
		
		
		protected static string defaultSubHeading = "[DATETIME]  [AUTHOR] : Generated by AuditWizard from Layton Technology, Inc.";
		protected static string defaultFooter = "The information contained in this report has been automatically generated based on data collected from Computers on your network and manually entered. Although Layton Technology, Inc. have taken all possible steps to ensure"
											+   " the accuracy of this data we cannot guarantee that (a) all computers owned by your organization have been audited or (b) the accuracy of any information manually entered. As such, this report should be treated as a guide to"
											+   " assist in ensuring software licensing compliancy. Layton Technology, Inc. cannot be held liable for any ommisions or inaccuracies which may be contained within this report.";
		/// <summary>
		/// This is the type of the report.  
		/// This must be set by derived reports so that the report can be saved/loaded correctly
		/// </summary>
		protected eReportType	_reportType;
		
		/// <summary>Name of the report</summary>
		protected string		_name;

		/// <summary>Description of this report</summary>
		protected string		_description;

		/// <summary>Date this report was created</summary>
		protected DateTime		_createdDate;
		
		/// <summary>Name of the user who created the report</summary>
		protected string		_author;
		
		/// <summary>List of AssetGroups to include in the report - note children of any groups included
		/// are also deemed to be included</summary>
		protected string		_selectedGroups = "";
		
		/// <summary>List of assets to include in the report</summary>
		protected string		_selectedAssets = "";
		
		/// <summary>Current publisher filter in force</summary>
		protected string		_publisherFilter = "";
		
		/// <summary>This is the base Data Set which will hold the data for the report</summary>
		protected DataSet		_reportDataSet = new DataSet();

		// This flag indicates whether or not the file is valid
		protected bool			_isValidFile;

		// This is the filename for the report definition
		protected string		_filename;

		/// <summary>Version of the report definition file (read from the file or hardwired above if writing)</summary>
		private string			_currentVersion;

		/// <summary>This field is set after we detect a change to the report definition</summary>
		protected bool			_hasChanged;
		
		/// <summary>This flag indicates that we originally read this report from a saved file</summary>
		protected bool			_readFromFile;
		
		/// <summary>List if auto-populated from the string of selected groups</summary>
		protected List<string> _listSelectedGroups = new List<string>();
		
		/// <summary>List if auto-populated from the string of selected assets</summary>
		protected List<string> _listSelectedAssets = new List<string>();
		
		/// <summary>This is the list of report sections used when exporting the report</summary>
		protected ExportSectionList _listReportSections = new ExportSectionList();

		/// <summary>
		/// This dictionary is used to provide mappings between full field names and the required label which
		/// we should display in the grid
		/// </summary>
		protected Dictionary<string, string> _dictionaryLabels = new Dictionary<string, string>();

		/// <summary>Checked if we should NOT include child assets in this report</summary>
		protected bool	_ignoreChildAssets;
		
		#endregion Data

		#region Properties

		[Category("Identity"), ReadOnly(true), Description("This is the name of the Report.")]
		public string Name
		{
			get { return _name; }
		}

		public string FileName
		{
			get { return _filename; }
		}
		
		public eReportType ReportType
		{
			get { return _reportType; }
			set { _hasChanged = _hasChanged || (_reportType != value); _reportType = value; }
		}
		
		[Category("Identity"), ReadOnly(true), Description("This is descriptive text for the report.")]
		public string Description
		{
			get { return _description; }
			set { _hasChanged = _hasChanged || (_description != value); _description = value;  }
		}

		[Category("Identity"), ReadOnly(true), Description("This is the date on which this report was originally created.")]
		public DateTime CreatedDate
		{
			get { return _createdDate; }
			set { _createdDate = value; }
		}

		[Category("Identity"), ReadOnly(true), Description("This is the name of the user who created the report.")]
		public string Author
		{
			get { return _author; }
			set { _hasChanged = _hasChanged || (_author != value); _author = value; }
		}

		[Category("Identity"), ReadOnly(true), Description("If not including all, this list contains those groups to include in the report.")]
		public string SelectedGroups
		{
			get { return _selectedGroups; }
			set { _hasChanged = _hasChanged || (_selectedGroups != value); _selectedGroups = value; ResetSelectedGroups(); }
		}

		[Category("Identity"), ReadOnly(true), Description("If not including all, this list contains those assets to include in the report.")]
		public string SelectedAssets
		{
			get { return _selectedAssets; }
			set { _hasChanged = _hasChanged || (_selectedAssets != value); _selectedAssets = value; ResetSelectedAssets(); }
		}

		[Category("Identity"), ReadOnly(true), Description("This is the DataSet which holds the data to be displayed by this report.")]
		public DataSet ReportDataSet
		{
			get { return _reportDataSet; }
		}

		/// <summary>
		/// TRUE if the report should EXCLUDE child assets, false otherwise
		/// </summary>
		public bool IgnoreChildAssets
		{
			get { return _ignoreChildAssets; }
			set { _hasChanged = _hasChanged || (_ignoreChildAssets != value); _ignoreChildAssets = value; }
		}

		/// <summary>Return whether this is a valid scanner configuration file</summary>
		public bool IsValidFile
		{ get { return _isValidFile; } }


		/// <summary>
		/// TRUE if the report has been modified and so needs to be saved, false otherwise
		/// </summary>
		public bool HasChanged
		{
			get { return _hasChanged; }
			set { _hasChanged = value; }
		}

		/// <summary>
		/// TRUE if the report was read from a saved definition, false otherwise
		/// </summary>
		public bool ReadFromFile
		{
			get { return _readFromFile; }
			set { _readFromFile = value; }
		}
		
		/// <summary>
		/// Returns the internal list of selected groups
		/// </summary>
		public List<String> SelectedGroupsList
		{
			get { return _listSelectedGroups; }
		}
		
		/// <summary>
		/// Returns the internal list of selected assets
		/// </summary>
		public List<String> SelectedAssetsList
		{
			get { return _listSelectedAssets; }
		}

		public void ResetSelectedGroups()
		{
			_listSelectedGroups = Utility.ListFromString(_selectedGroups, ';', true);
		}

		public void ResetSelectedAssets()
		{
			_listSelectedAssets = Utility.ListFromString(_selectedAssets, ';', true);
		}
		
		public ExportSectionList ReportSections
		{
			get { return _listReportSections; }
		}

		public string PublisherFilter
		{
			set { _publisherFilter = value; }
		}

		public Dictionary<string ,string> Labels
		{
			get { return _dictionaryLabels; }
		}
		
		#endregion Properties
		
		#region XMLStrings

		// String storage for sections and values in the XML audit Data File
		protected const string S_REPORT_DEFINITION = "ReportDefinition";

		// General Section  (TOP LEVEL)
		protected const string S_GENERAL = "General";
		protected const string V_GENERAL_TYPE = "ReportType";
		protected const string V_GENERAL_AUTHOR = "Author";
		protected const string V_GENERAL_NAME = "Name";
		protected const string V_GENERAL_DESCRIPTION = "Description";
		protected const string V_GENERAL_VERSION = "Version";

		// Report Sections 
		protected const string S_REPORT_SECTIONS = "ReportSections";
		protected const string S_REPORT_SECTION = "ReportSection";

		// Lables Sections 
		protected const string S_REPORT_LABELS	= "Labels";
		protected const string S_REPORT_LABEL	= "Label";
		protected const string V_LABEL_MAPPING	= "Mapping";
		

		// Scope
		protected const string S_SCOPE	= "Scope";
		protected const string V_SCOPE_LOCATIONS = "locations";
		protected const string V_SCOPE_ASSETS = "Assets";
		protected const string V_SCOPE_IGNORECHILDASSETS = "IgnoreChildAssets";
		
		#endregion

		#region Constructor
		
		public ReportDefinition()
		{
			_name = "";
			_description = "";
			_author = System.Environment.UserName;
			_createdDate = DateTime.Now;
			_selectedAssets = "";
			_selectedGroups = "";
			_hasChanged = false;
			_readFromFile = false;
			_ignoreChildAssets = true;
			
			// Build the list of report sections - every report will have a header, subheader and footer
			ExportSection headerSection = new ExportSection(ExportSection.eSectionType.header, new FormattedText());
			headerSection.FormattedText.ForeColor = Color.DarkBlue;
			headerSection.FormattedText.FontData.Bold = Infragistics.Win.DefaultableBoolean.True;
			headerSection.FormattedText.FontData.Name = "Verdana";
			headerSection.FormattedText.FontData.SizeInPoints = 10;
			headerSection.FormattedText.HorizontalAlignment = Infragistics.Win.HAlign.Center;
			
			// Set the subheading to show the Date, Author and Copyright
			ExportSection subheadingSection = new ExportSection(ExportSection.eSectionType.subheader
															  , new FormattedText(defaultSubHeading));
			subheadingSection.FormattedText.FontData.Underline = Infragistics.Win.DefaultableBoolean.True;
			subheadingSection.FormattedText.FontData.Name = "Verdana";
			subheadingSection.FormattedText.FontData.SizeInPoints = 8;
																		  
			// Default footer
			ExportSection footerSection = new ExportSection(ExportSection.eSectionType.footer
															, new FormattedText(defaultFooter));
			footerSection.FormattedText.FontData.Name = "Verdana";
			footerSection.FormattedText.FontData.SizeInPoints = 6;

			// Add these sections
			_listReportSections.Clear();
			_listReportSections.AddRange(new ExportSection[] { headerSection ,subheadingSection ,footerSection } );
		}
		
		#endregion Constructor

		#region Methods
		
		public bool ReportName (string name)
		{
			// Ensure tha the name specified does not contain any illegal characters
			if (name.IndexOfAny(Path.GetInvalidFileNameChars()) != -1)
				return false;

			// Default the name if not specified
			if (name == "")
				name = "Default";
			
			// Build a file name from the path and the report name
			_hasChanged = _hasChanged || (_name != name);					
				_name = name;
			_filename = Path.Combine(Application.StartupPath, @"reports\custom_reports\" + Name + ReportDefinition.REPORTEXTENSION);
			return true;	
		}
		
		/// <summary>
		/// This is an abstract class to actually generate the report
		/// </summary>
		public virtual void GenerateReport (UltraGrid grid)
		{
		}

		/// <summary>
		/// Abstract class for writing the report - all report typs must write themselves
		/// </summary>
		public virtual int WriteReport	()
		{
			return -1;
		}
		
		/// <summary>
		/// Virtual function to allow row specific formatting to be performed for each report
		/// </summary>
		/// <param name="gridRow"></param>
		public virtual void InitializeGridRow (UltraGridRow gridRow)
		{
		}
		
		
		/// <summary>
		/// Called to set the scope fopr this report that is the groups and assets to be included in the report
		/// </summary>
		/// <param name="listSelectedGroups"></param>
		/// <param name="listSelectedAssets"></param>
		public void SetReportScope (string selectedGroups ,string selectedAssets)
		{
			SelectedGroups = selectedGroups;
			SelectedAssets = selectedAssets;
		}

		
		/// <summary>
		/// return the first section in the report with the specified type
		/// </summary>
		/// <param name="sectionType"></param>
		/// <returns></returns>
		public ExportSection GetReportSection (ExportSection.eSectionType sectionType)
		{
			return _listReportSections.GetSection(sectionType);
		}

		/// <summary>
		/// Override ToString to return the report name
		/// </summary>
		/// <returns></returns>
		public override string ToString()
		{
			return Name;
		}
		
		
		public void UpdateFormattedText()
		{
			DateTime now = DateTime.Now;
			
			// Create a dictionary of the possible substitutions which we will allow
			Dictionary <string, string> substitutions = new Dictionary<string,string>();
			substitutions.Add("[DATE]", now.ToShortDateString());
			substitutions.Add("[DATETIME]", now.ToShortDateString() + " " + now.ToShortTimeString());
			substitutions.Add("[LONGDATE]", now.ToLongDateString());
			substitutions.Add("[LONGDATETIME]", now.ToLongDateString() + " " + now.ToLongTimeString());
			substitutions.Add("[AUTHOR]", _author);
			substitutions.Add("[NAME]", _name);	
			
			// Now apply these substitutions to each of the sections
			foreach (ExportSection section in _listReportSections)
			{
				section.FormattedText.FormatUsingSubstitutions(substitutions);
			}	
		}
		
		
		
		protected void SaveTemporaryLayout (UltraGrid grid)
		{
			string templateName = Path.Combine(Application.StartupPath, @"reports\xxxtempxxx_layout.xml");
			if (File.Exists(templateName))
				File.Delete(templateName);

			grid.DisplayLayout.SaveAsXml(templateName);
		} 				
		
		
		
		/// <summary>
		/// Load the temporary template - if this does not exist load the report template if one can be found
		/// </summary>
		/// <param name="grid"></param>
		protected void LoadTemporaryLayout (UltraGrid grid)
		{
			string templateName = Path.Combine(Application.StartupPath, @"reports\xxxtempxxx_layout.xml");
			if (File.Exists(templateName))
			{
				grid.DisplayLayout.LoadFromXml(templateName);
				File.Delete(templateName);
			}		
			else
			{
				templateName = Path.Combine(Application.StartupPath, @"reports\" + Name + "_layout.xml");
				if (File.Exists(templateName))
					grid.DisplayLayout.LoadFromXml(templateName);
			}		
		}
		
		
		#endregion Methods

		#region READER Functions

		/// <summary>
		/// Read the Audit Scanner Configuration File into our internal buffer
		/// </summary>
		/// <returns></returns>
		public virtual bool ReadReport()
		{
			// Create a log file
			LogFile ourLog = LogFile.Instance;
			ourLog.Write("Reading Report Definition from " + _filename, true);
			
			// Erase the default sections
			_listReportSections.Clear();
			
			//
			XmlTextReader textReader;
			XmlSimpleElement xmlSimpleElement = new XmlSimpleElement("junk");
			XmlParser xmlParser;

			// First of all parse the file
			try
			{
				textReader = new XmlTextReader(_filename);
				xmlParser = new XmlParser();
				xmlSimpleElement = xmlParser.Parse(textReader);
				textReader.Close();
			}

			catch (Exception ex)
			{
				ourLog.Write("Exception occurred while report definition file, the error was " + ex.Message, true);
				return false;
			}

			// If we can't find the 'Report Defintion' element then this is NOT a valid file
			_isValidFile = (xmlSimpleElement.TagName == S_REPORT_DEFINITION);
			if (!_isValidFile)
			{
				ourLog.Write("The [" + S_REPORT_DEFINITION + "] section was not found and therefore the file is invalid", true);
				return false;
			}

			// Now iterate through the data recovered 
			foreach (XmlSimpleElement childElement in xmlSimpleElement.ChildElements)
			{
				ProcessElementRead(childElement);
			}

			// Flag that we read this definition from a file
			ReadFromFile = true;
			
			return true;
		}


		/// <summary>
		/// Called as we parse a top level element from the configuration file
		/// </summary>
		/// <param name="xmlElement"></param>
		protected void ProcessElementRead(XmlSimpleElement xmlSimpleElement)
		{
			string elementName = xmlSimpleElement.TagName;

			// OK what sort of element is it?
			switch (elementName)
			{
				case S_REPORT_DEFINITION:
					break;

				case S_GENERAL:
					ReadGeneral(xmlSimpleElement);
					break;

				case S_REPORT_SECTIONS:
					ReadReportSections(xmlSimpleElement);
					break;

				case S_REPORT_LABELS:
					ReadReportLabels(xmlSimpleElement);
					break;
					
				case S_SCOPE:
					ReadScope(xmlSimpleElement);
					break;

				default:
					break;
			}
			return;
		}


		/// <summary>
		/// We have parsed the 'General' element so now parse the items 
		/// within this section noting that we terminate parsing when we reach the end 
		/// of the section.
		/// </summary>
		/// <param name="xmlElement"></param>
		protected void ReadGeneral(XmlSimpleElement xmlSimpleElement)
		{
			foreach (XmlSimpleElement childElement in xmlSimpleElement.ChildElements)
			{
				switch (childElement.TagName)
				{
					case V_GENERAL_AUTHOR:
						_author = childElement.Text;
						break;

					case V_GENERAL_TYPE:
						_reportType = (eReportType)childElement.TextAsInt;
						break;

					case V_GENERAL_NAME:
						_name = childElement.Text;
						break;

					case V_GENERAL_DESCRIPTION:
						_description = childElement.Text;
						break;

					case V_GENERAL_VERSION:
						_currentVersion = childElement.Text;
						break;

					default:
						break;
				}
			}
		}




		/// <summary>
		/// We have parsed the 'Report Sections' element so now parse the items 
		/// within this section noting that we terminate parsing when we reach the end 
		/// of the section.
		/// </summary>
		/// <param name="xmlElement"></param>
		protected void ReadReportSections(XmlSimpleElement xmlSimpleElement)
		{
			foreach (XmlSimpleElement childElement in xmlSimpleElement.ChildElements)
			{
				switch (childElement.TagName)
				{
					// For each section we create a new section and ask it to populate itself
					case S_REPORT_SECTION:
						ExportSection reportSection = new ExportSection();
						reportSection.LoadFromXml(childElement);
						_listReportSections.Add(reportSection);
						break;

					default:
						break;
				}
			}
		}



		/// <summary>
		/// We have parsed the 'Labels' element so now parse the items 
		/// within this section noting that we terminate parsing when we reach the end 
		/// of the section.
		/// </summary>
		/// <param name="xmlElement"></param>
		protected void ReadReportLabels(XmlSimpleElement xmlSimpleElement)
		{
			// Create a new dictionary
			_dictionaryLabels = new Dictionary<string,string>();
			
			foreach (XmlSimpleElement childElement in xmlSimpleElement.ChildElements)
			{
				switch (childElement.TagName)
				{
					// For each section we create a new section and ask it to populate itself
					case S_REPORT_LABEL:
						ReadReportLabel(childElement);
						break;

					default:
						break;
				}
			}
		}


		/// <summary>
		/// We have parsed the an individual label element so now parse its attributes
		/// </summary>
		/// <param name="xmlElement"></param>
		protected void ReadReportLabel(XmlSimpleElement xmlSimpleElement)
		{
			foreach (XmlSimpleElement childElement in xmlSimpleElement.ChildElements)
			{
				if (childElement.TagName == V_LABEL_MAPPING)
				{
					string value = childElement.Text;
					int index = value.LastIndexOf("###");
					if (index != -1)
					{
						string field = value.Substring(0 ,index);
						string label = value.Substring(index + 3);
						_dictionaryLabels.Add(field ,label);
					} 				
				}
			}
		}


		/// <summary>
		/// Process the SCOPE Section
		/// </summary>
		/// <param name="xmlSimpleElement"></param>
		protected void ReadScope(XmlSimpleElement xmlSimpleElement)
		{
			foreach (XmlSimpleElement childElement in xmlSimpleElement.ChildElements)
			{
				switch (childElement.TagName)
				{
					case V_SCOPE_LOCATIONS:
						SelectedGroups = childElement.Text;
						break;

					case V_SCOPE_ASSETS:
						SelectedAssets = childElement.Text;
						break;

					case V_SCOPE_IGNORECHILDASSETS:
						IgnoreChildAssets = childElement.TextAsBoolean;
						break;

					default:
						break;
				}
			}
		}

		#endregion READER Functions

		#region WRITER Functions

		//
		//    SaveGeneral
		//    ===========
		//
		//    Create the 'General' section 
		//
		protected void SaveGeneral(XmlTextWriterEx writer)
		{
			writer.StartSection(S_GENERAL);		// ...add a 'General' section
			//
			writer.WriteSetting(V_GENERAL_AUTHOR, "AuditWizard");
			writer.WriteSetting(V_GENERAL_TYPE, ((int)_reportType).ToString());
			writer.WriteSetting(V_GENERAL_NAME, _name);
			writer.WriteSetting(V_GENERAL_DESCRIPTION, _description);
			writer.WriteSetting(V_GENERAL_VERSION, _currentVersion);
			//
			writer.EndSection();				// ...out of 'General' section
			
			// Write the report sections
			SaveReportSections(writer);

			// Write the column mappings (if any)
			if (_dictionaryLabels.Count != 0)
				SaveReportLabels(writer);
			
			// Flag as no changes anymore
			_hasChanged = false;
		}


		//
		//    SaveReportSections
		//    ===================
		//
		//    Create the 'ReportSections' section 
		//
		protected void SaveReportSections(XmlTextWriterEx writer)
		{
			// We will also save the report sections
			writer.StartSection(S_REPORT_SECTIONS);		// ...add a 'General' section
			
			// Iterate through each section but get them to save themselves
			foreach (ExportSection reportSection in _listReportSections)
			{
				writer.StartSection(S_REPORT_SECTION);
				reportSection.SaveToXml(writer);
				writer.EndSection();
			}

			writer.EndSection();
		}


		//
		//    SaveReportLabels
		//    =================
		//
		//    Create the 'Labels' section 
		//
		protected void SaveReportLabels (XmlTextWriterEx writer)
		{
			// We will also save the report sections
			writer.StartSection(S_REPORT_LABELS);		

			// Iterate through each section but get them to save themselves
			foreach (KeyValuePair<string ,string> kvp in _dictionaryLabels)
			{
				writer.StartSection(S_REPORT_LABEL);
				writer.WriteSetting(V_LABEL_MAPPING, kvp.Key + "###" + kvp.Value);
				writer.EndSection();
			}

			writer.EndSection();
		}
	
		
		/// <summary>
		/// Save settings into the SCOPE section of the Report Definition file
		/// </summary>
		/// <param name="writer"></param>
		protected void SaveScope(XmlTextWriterEx writer)
		{
			writer.StartSection(S_SCOPE);
			//
			writer.WriteSetting(V_SCOPE_LOCATIONS, _selectedGroups);
			writer.WriteSetting(V_SCOPE_ASSETS, _selectedAssets);
			writer.WriteSetting(V_SCOPE_IGNORECHILDASSETS, _selectedAssets);
			//
			writer.EndSection();
		}

		#endregion WRITER Functions
		
	}
}
